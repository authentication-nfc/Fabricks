<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Fabricks Style - 360 Viewer</title>
    <style>
        /* リンク画像の共通設定 */
.link-image-container {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    z-index: 20; /* 回転画像(10)より手前に出す */
}

.link-image-container img {
    width: 250px; /* ★ボタン画像のサイズ（お好みで変えてください） */
    height: auto;
    cursor: pointer;
}

/* 配置場所の高さ指定 */
.pos-link-bottom {
    top: 85%; /* ★背景の上から85%の位置（場所を変えたいときはここを調整） */
}
        body, html { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            background-color: #000; 
            overflow-x: hidden; 
        }

        /* 1500x11000の背景比率 */
        .scrolling-wrapper {
            position: relative;
            width: 100%;
            max-width: 1500px;
            margin: 0 auto;    
            height: 733.33vw;  
            background: url('long-background.jpg') no-repeat top center;
            background-size: 100% auto;
        }

        #viewer-container {
            position: absolute;
            top: 17%; 
            left: 50%;
            transform: translate(-50%, -50%);
            width: 95%; 
            max-width: 1450px; 
            aspect-ratio: 1 / 1;
            /* touch-action: pan-y でブラウザに上下スクロールを許可しつつ、左右をJSで取る */
            touch-action: pan-y; 
            cursor: ew-resize;
            z-index: 10;
        }

        #product-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            pointer-events: none;
            filter: drop-shadow(0 15px 35px rgba(0,0,0,0.3));
        }
    </style>
</head>
<body>

    <div class="scrolling-wrapper">
        <div id="viewer-container">
            <div class="link-image-container pos-link-bottom">
    <a href="https://www.google.com" target="_blank"> <img src="button.png" alt="リンクボタン"> </a>
</div>
            <img id="product-image" src="image_01.jpg">
        </div>
    </div>

    <script>
        const imgElement = document.getElementById('product-image');
        const totalFrames = 18;
        const images = [];

        for (let i = 1; i <= totalFrames; i++) {
            const num = i.toString().padStart(2, '0');
            images.push(`image_${num}.jpg`);
            new Image().src = `image_${num}.jpg`;
        }

        let currentFrameIndex = 0; 
        let lastFrameIndex = 0;
        let isDragging = false;
        let startX = 0;
        let lastX = 0;
        let velocity = 0; 
        let rafId = null;

        const updateFrame = (offset) => {
            let relativePos = offset + (lastFrameIndex <= 9 ? lastFrameIndex : lastFrameIndex - 18);
            if (relativePos < -8) { relativePos = -8; velocity = 0; } 
            if (relativePos > 9) { relativePos = 9; velocity = 0; }
            let finalFrame = relativePos >= 0 ? relativePos : 18 + relativePos;

            if (finalFrame !== currentFrameIndex) {
                imgElement.src = images[finalFrame];
                currentFrameIndex = finalFrame;
            }
        };

        const animateInertia = () => {
            if (!isDragging) {
                velocity *= 0.92;
                if (Math.abs(velocity) > 0.1) {
                    let nextRelative = (currentFrameIndex <= 9 ? currentFrameIndex : currentFrameIndex - 18) + (velocity / 15);
                    if (nextRelative < -8) nextRelative = -8;
                    if (nextRelative > 9) nextRelative = 9;
                    let nextFrame = Math.round(nextRelative >= 0 ? nextRelative : 18 + nextRelative);
                    if (nextFrame !== currentFrameIndex) {
                        imgElement.src = images[nextFrame];
                        currentFrameIndex = nextFrame;
                    }
                    rafId = requestAnimationFrame(animateInertia);
                } else {
                    lastFrameIndex = currentFrameIndex;
                }
            }
        };

        const startAction = (x) => {
            isDragging = true;
            startX = x;
            lastX = x;
            lastFrameIndex = currentFrameIndex;
            velocity = 0;
            cancelAnimationFrame(rafId);
        };

        const moveAction = (x) => {
            if (!isDragging) return;
            velocity = x - lastX;
            lastX = x;
            const sensitivity = 15;
            const frameOffset = Math.floor((x - startX) / sensitivity);
            updateFrame(frameOffset);
        };

        const container = document.getElementById('viewer-container');

        // マウス操作
        container.addEventListener('mousedown', (e) => startAction(e.pageX));
        window.addEventListener('mousemove', (e) => {
            if (isDragging) moveAction(e.pageX);
        });
        window.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                lastFrameIndex = currentFrameIndex;
                animateInertia();
            }
        });

        // タッチ操作（スクロールを殺さない設定）
        container.addEventListener('touchstart', (e) => {
            startAction(e.touches[0].pageX);
        }, { passive: true });

        container.addEventListener('touchmove', (e) => {
            if (isDragging) {
                moveAction(e.touches[0].pageX);
            }
        }, { passive: true });

        container.addEventListener('touchend', () => {
            if (isDragging) {
                isDragging = false;
                lastFrameIndex = currentFrameIndex;
                animateInertia();
            }
        });
    </script>
</body>
</html>
                    let nextRelative = (current
