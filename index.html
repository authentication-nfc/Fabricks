<script>
    const imgElement = document.getElementById('product-image');
    const totalFrames = 18;
    const images = [];

    for (let i = 1; i <= totalFrames; i++) {
        const num = i.toString().padStart(2, '0');
        images.push(`image_${num}.jpg`);
        new Image().src = `image_${num}.jpg`;
    }

    let currentFrameIndex = 0; 
    let lastFrameIndex = 0;
    let isDragging = false;
    let startX = 0;
    let velocity = 0; // 回転の速度
    let lastX = 0;
    let rafId = null; // アニメーション用ID

    // フレームを更新する共通関数
    const updateFrame = (offset) => {
        // 1番(正面)を中心に10番と11番で止まるロジックを適用
        let relativePos = offset + (lastFrameIndex <= 9 ? lastFrameIndex : lastFrameIndex - 18);
        
        if (relativePos < -8) {
            relativePos = -8;
            velocity = 0; // 壁に当たったら速度をゼロに
        } 
        if (relativePos > 9) {
            relativePos = 9;
            velocity = 0; // 壁に当たったら速度をゼロに
        }

        let finalFrame = relativePos >= 0 ? relativePos : 18 + relativePos;

        if (finalFrame !== currentFrameIndex) {
            imgElement.src = images[finalFrame];
            currentFrameIndex = finalFrame;
        }
    };

    // 慣性アニメーションのループ
    const animateInertia = () => {
        if (!isDragging) {
            velocity *= 0.92; // 摩擦（数字が小さいほどすぐ止まる）
            
            if (Math.abs(velocity) > 0.1) {
                // 速度を位置の変化に変換（感度15に合わせる）
                const frameOffset = Math.round(velocity / 15);
                
                // 現在のインデックスを更新
                let nextRelative = (currentFrameIndex <= 9 ? currentFrameIndex : currentFrameIndex - 18) + (velocity / 15);
                
                // 制限
                if (nextRelative < -8) nextRelative = -8;
                if (nextRelative > 9) nextRelative = 9;
                
                let nextFrame = Math.round(nextRelative >= 0 ? nextRelative : 18 + nextRelative);
                
                if (nextFrame !== currentFrameIndex) {
                    imgElement.src = images[nextFrame];
                    currentFrameIndex = nextFrame;
                }
                
                rafId = requestAnimationFrame(animateInertia);
            } else {
                lastFrameIndex = currentFrameIndex;
            }
        }
    };

    const startAction = (x) => {
        isDragging = true;
        startX = x;
        lastX = x;
        lastFrameIndex = currentFrameIndex;
        velocity = 0;
        cancelAnimationFrame(rafId);
    };

    const moveAction = (x) => {
        if (!isDragging) return;
        
        const diffX = x - startX;
        velocity = x - lastX; // 直前の動きから速度を計算
        lastX = x;

        const sensitivity = 15;
        const frameOffset = Math.floor(diffX / sensitivity);
        updateFrame(frameOffset);
    };

    const endAction = () => {
        if (!isDragging) return;
        isDragging = false;
        lastFrameIndex = currentFrameIndex;
        animateInertia(); // 指を離したら慣性スタート
    };

    const container = document.getElementById('viewer-container');
    container.addEventListener('mousedown', (e) => startAction(e.pageX));
    window.addEventListener('mousemove', (e) => moveAction(e.pageX));
    window.addEventListener('mouseup', endAction);

    container.addEventListener('touchstart', (e) => startAction(e.touches[0].pageX));
    container.addEventListener('touchmove', (e) => {
        e.preventDefault(); 
        moveAction(e.touches[0].pageX);
    }, { passive: false });
    window.addEventListener('touchend', endAction);
</script>
